//
// Copyright (c) 2016-2020 SiFive, Inc. -- Proprietary and Confidential
// All Rights Reserved.
//
// NOTICE: All information contained herein is, and remains the
// property of SiFive, Inc. The intellectual and technical concepts
// contained herein are proprietary to SiFive, Inc. and may be covered
// by U.S. and Foreign Patents, patents in process, and are protected by
// trade secret or copyright law.
//
// This work may not be copied, modified, re-published, uploaded,
// executed, or distributed in any way, in any medium, whether in whole
// or in part, without prior written permission from SiFive, Inc.
//
// The copyright notice above does not evidence any actual or intended
// publication or disclosure of this source code, which includes
// information that is confidential and/or proprietary, and is a trade
// secret, of SiFive, Inc.
//
// Instance ID: b21cef66-00f3-44d5-a188-807f478b1270, 00000000-0000-0000-0000-000000000000, 00000000-0000-0000-0000-000000000000

// VCS coverage exclude_file
// Autogenerated DPI Bundle monitor

// foreign export ccall __core_monitor :: CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> IO ()
// __core_monitor :: CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> CULong -> IO ()
// core_monitor inst rd1val rd1src rd0val rd0src wrenf wrenx wrdata wrdst pc valid timer hartid priv_mode excpt = return ()

// void core_monitor(size_t inst, size_t rd1val, size_t rd1src, size_t rd0val, size_t rd0src, size_t wrenf, size_t wrenx, size_t wrdata, size_t wrdst, size_t pc, size_t valid, size_t timer, size_t hartid, size_t priv_mode, size_t excpt);
// core_monitor(inst, rd1val, rd1src, rd0val, rd0src, wrenf, wrenx, wrdata, wrdst, pc, valid, timer, hartid, priv_mode, excpt);

module core_monitor (
    input [31:0] m_0_inst, input [31:0] m_0_rd1val, input [4:0] m_0_rd1src, input [31:0] m_0_rd0val, input [4:0] m_0_rd0src, input [0:0] m_0_wrenf, input [0:0] m_0_wrenx, input [31:0] m_0_wrdata, input [4:0] m_0_wrdst, input [31:0] m_0_pc, input [0:0] m_0_valid, input [31:0] m_0_timer, input [31:0] m_0_hartid, input [2:0] m_0_priv_mode, input [0:0] m_0_excpt, input [0:0] m_0_reset, input [0:0] m_0_clock);
  logic [4:0] rf_rd_addr;
  logic [31:0] rf_rd_wdata;
  assign rf_rd_wdata = system.tile.core.rf._EVAL_7__EVAL_10_data;
  assign rf_rd_wren = system.tile.core.rf._EVAL_7__EVAL_10_en;
  assign rf_rd_addr = system.tile.core.rf._EVAL_7__EVAL_10_addr;
`ifdef USE_DPI
`ifndef SYNTHESIS
    import "DPI-C" context function void core_monitor(input longint m_inst, input longint m_rd1val, input longint m_rd1src, input longint m_rd0val, input longint m_rd0src, input longint m_wrenf, input longint m_wrenx, input longint m_wrdata, input longint m_wrdst, input longint m_pc, input longint m_valid, input longint m_timer, input longint m_hartid, input longint m_priv_mode, input longint m_excpt);
    always @(posedge m_0_clock) if (!m_0_reset) begin
       core_monitor(m_0_inst, m_0_rd1val, m_0_rd1src, m_0_rd0val, m_0_rd0src, m_0_wrenf, m_0_wrenx, m_0_wrdata, m_0_wrdst, m_0_pc, m_0_valid, m_0_timer, m_0_hartid, m_0_priv_mode, m_0_excpt);
    end
`endif
`endif

//core trace

tracer 	core_tracer(
  .clk_i			      (m_0_clock),                      
  .rst_ni			      (m_0_reset),                        
  .hart_id_i			  (m_0_hartid),
  .rvfi_valid			  (m_0_valid),     
  .rvfi_pc_rdata		(m_0_pc),					
  .rvfi_insn			  (m_0_inst),		 
  .rvfi_pc_wdata		(m_0_pc),				
  .rvfi_rs1_addr		(m_0_rd0src),                
  .rvfi_rs2_addr		(m_0_rd1src),                              
  .rvfi_rs1_rdata	  (m_0_rd0val),               
  .rvfi_rs2_rdata		(m_0_rd1val),                
  .rvfi_rd_addr		  (m_0_wrdst),                
  .rvfi_rd_wdata		(rf_rd_wdata),
  .rvfi_rd_wren 		(m_0_wrenx),
  .rf_rd_wdata      (rf_rd_wdata),
  .rf_rd_wren       (rf_rd_wren),
  .rf_rd_addr       (rf_rd_addr),
  .rvfi_mem_addr		(32'h0),     
  .rvfi_mem_rmask		(4'hf),
  .rvfi_mem_wmask		(4'hf),       
  .rvfi_mem_rdata		(32'h0),
  .rvfi_mem_wdata		(32'h0)        
);
endmodule
